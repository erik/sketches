#!/usr/bin/env python3

import os
import os.path
import readline
import subprocess
import signal
import sys
import threading
import time


def init_readline():
    # TODO: tab completer
    readline.parse_and_bind('tab: complete')


def control_code(fn):
    def wrap(*args, **kw):
        ch = fn(*args)
        sys.stdout.write(ch)
    return wrap

class ANSI:
    '''FIXME: this is really ugly.'''
    @control_code
    def clear_line():
        return '\x1B[2K'

    @control_code
    def start_of_line():
        return '\x1B[0G'

    @control_code
    def start_of_prev():
        return '\x1B[1F'

    @control_code
    def start_of_next():
        return '\x1B[1E'

    @control_code
    def reset():
        return '\x1Bc'


class sync_writes:
    _LOCK = threading.Lock()

    def __enter__(self):
        self._LOCK.acquire()

    def __exit__(self, type, value, traceback):
        readline.redisplay()
        self._LOCK.release()


def tail_file(path, nlines=1000):
    return subprocess.Popen([
        'tail',
        '-%d' % nlines,
        '-F',
        path
    ], stdout=subprocess.PIPE)


_next_redraw_at = None
_redraw_event = threading.Event()


def _redraw_debouncer():
    '''readline.redisplay() doesn't force a redraw, but SIGWINCH does.

    Also, debounce by deferring the SIGWINCH until we haven't received
    a new line for a few ms (to prevent a flood of kill calls on
    startup).
    '''

    while True:
        _redraw_event.wait()
        _redraw_event.clear()

        time.sleep(max(_next_redraw_at - time.time(), 0))

        if _redraw_event.is_set():
            continue

        # Don't want to trip this in the middle of a write
        with sync_writes():
            os.kill(os.getpid(), signal.SIGWINCH)
            time.sleep(0.250)


def schedule_redraw(delay_ms=200):
    global _next_redraw_at

    _next_redraw_at = time.time() + (delay_ms / 1000.0)
    _redraw_event.set()


def _print_lines(out):
    with sync_writes():
        ANSI.reset()

    for line in out:
        # TODO: possibly wrap lines if they're wider than the term?
        line = line.decode('utf-8').rstrip()

        with sync_writes():
            ANSI.clear_line()
            ANSI.start_of_line()
            print(line)
            ANSI.start_of_next()

            schedule_redraw()


def print_lines(proc):
    return threading.Thread(
        target=_print_lines,
        args=[proc],
        daemon=True
    ).start()


BG_BLACK = '\x1B[40m'
FG_WHITE = '\x1B[37m'
RESET = '\x1B[0m'

def input_loop(path, name):
    inp = os.path.join(path, '__in')

    prompt = '%s%s[ %s ]%s ' % (BG_BLACK, FG_WHITE, name, RESET)

    def write_line(line):
        b = (line + '\n').encode('utf-8')
        with open(inp, 'wb', buffering=0) as fifo:
            fifo.write(b)

    while True:
        try:
            line = input(prompt).strip()

            with sync_writes():
                ANSI.start_of_prev()
                ANSI.clear_line()

            if line == '':
                continue

            # Jump to another buffer
            elif line.startswith('/switch'):
                _, buf = line.split(' ', 2)
                return buf

            # Force full re-render
            elif line == '/refresh':
                return name

            write_line(line)

        except (KeyboardInterrupt, EOFError):
            break


def select_buffer_path(path, name):
    for f in ['__in', '__out']:
        f = os.path.join(path, f)

        if not os.path.exists(f):
            print('%s: no such directory' % f)
            sys.exit(1)

    proc = tail_file(os.path.join(path, '__out'))
    print_lines(proc.stdout)

    next_buf = input_loop(path, name)

    # Kill the `tail` command to clean up after ourselves.
    proc.kill()

    return next_buf


def main():
    if len(sys.argv) != 2:
        print('usage: %s PATH' % sys.argv[0])
        sys.exit(1)

    full_path = sys.argv[1].rstrip('/')

    name = os.path.basename(full_path)
    path = os.path.dirname(full_path)

    threading.Thread(
        target=_redraw_debouncer,
        daemon=True
    ).start()

    while name is not None:
        name = run_client(path, name)


def run_client(path, name):
    init_readline()
    print('~~~ %s ~~~' % name)

    full_path = os.path.join(path, name)
    if not os.path.exists(full_path):
        print('%s: no such directory' % full_path)
        sys.exit(1)

    name = select_buffer_path(full_path, name)

    # Special case: server buffer is top level in directory
    if name == '$server':
        return ''

    return name


if __name__ == '__main__':
    main()
