#!/usr/bin/env python3

import os
import os.path
import readline
import subprocess
import sys
import threading
import time


def init_readline():
    # TODO: tab completer
    readline.parse_and_bind('tab: complete')


def control_code(fn):
    def wrap(*args, **kw):
        ch = fn(*args)
        sys.stdout.write(ch)
    return wrap

class ANSI:
    '''FIXME: this is really ugly.'''
    @control_code
    def save_cursor():
        return '\x1B[s'

    @control_code
    def restore_cursor():
        return '\x1B[u'

    @control_code
    def clear_line():
        return '\x1B[2K'

    @control_code
    def start_of_line():
        return '\x1B[0G'

    @control_code
    def start_of_prev():
        return '\x1B[1F'

    @control_code
    def start_of_next():
        return '\x1B[1E'

    @control_code
    def cursor_up(amt):
        return '\r\x1B[%sA' % amt

    @control_code
    def cursor_down(amt):
        return '\r\x1B[%sB' % amt

    @control_code
    def reset():
        return '\x1Bc'


_LOCK = threading.Lock()


class sync_writes:
    def __enter__(self):
        _LOCK.acquire()
    def __exit__(self, type, value, traceback):
        readline.redisplay()
        _LOCK.release()


def tail_file(path, nlines=1000):
    return subprocess.Popen([
        'tail',
        '-%d' % nlines,
        '-F',
        path
    ], stdout=subprocess.PIPE)

def _print_lines(out):
    with sync_writes():
        ANSI.reset()

    for line in out:
        # TODO: possibly wrap lines if they're wider than the term?
        line = line.decode('utf-8').rstrip()

        with sync_writes():
            ANSI.clear_line()
            ANSI.start_of_line()
            print(line)
            ANSI.start_of_next()

            readline.redisplay()


def print_lines(proc):
    return threading.Thread(
        target=_print_lines,
        args=[proc],
        daemon=True
    ).start()


BG_BLACK = '\x1B[40m'
FG_WHITE = '\x1B[37m'
RESET = '\x1B[0m'

def input_loop(path, name):
    inp = os.path.join(path, '__in')

    prompt = '%s%s[ %s ]%s ' % (BG_BLACK, FG_WHITE, name, RESET)

    def write_line(line):
        b = (line + '\n').encode('utf-8')
        with open(inp, 'wb', buffering=0) as fifo:
            fifo.write(b)

    while True:
        try:
            line = input(prompt).strip()

            with sync_writes():
                ANSI.start_of_prev()
                ANSI.clear_line()
                ANSI.start_of_next()

            if line == '':
                continue

            # Jump to another buffer
            elif line.startswith('/switch'):
                _, buf = line.split(' ', 2)
                return buf

            # Force full re-render
            elif line == '/refresh':
                return name

            write_line(line)

        except (KeyboardInterrupt, EOFError):
            break


def select_buffer_path(path, name):
    for f in ['__in', '__out']:
        f = os.path.join(path, f)

        if not os.path.exists(f):
            print('%s: no such directory' % f)
            sys.exit(1)

    proc = tail_file(os.path.join(path, '__out'))
    print_lines(proc.stdout)

    next_buf = input_loop(path, name)
    proc.kill()

    return next_buf


def main():
    if len(sys.argv) != 2:
        print('usage: %s PATH' % sys.argv[0])
        sys.exit(1)

    full_path = sys.argv[1].rstrip('/')

    name = os.path.basename(full_path)
    path = os.path.dirname(full_path)

    while name is not None:
        name = run_client(path, name)


def run_client(path, name):
    init_readline()
    print('~~~ %s ~~~' % name)

    full_path = os.path.join(path, name)
    if not os.path.exists(full_path):
        print('%s: no such directory' % full_path)
        sys.exit(1)

    name = select_buffer_path(full_path, name)

    # Special case: server buffer is top level in directory
    if name == '$server':
        return ''

    return name


if __name__ == '__main__':
    main()
