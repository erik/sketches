package main

import (
	"database/sql"
	"flag"
	"fmt"
	"log"
	"os"

	_ "github.com/lib/pq"
)

const USAGE = `postdoc - a schema research tool

Usage:
  postdoc       <db_url> [-http <bind_host>] [-s <schema>...] [-json <file>]
  postdoc serve <file>   [-http <bind_host>]

Arguments:
  file               path to JSON file previously generated by postdoc
  db_url             e.g. "postgres://user@hostname:port/database?options"
                     e.g. "host=/var/run/postgresql dbname=foo"

Options:
  -http <bind_host>  addr to serve rendered schema on [default: ':8080']
  -json <file>       output rendered schema as json to <file>
`

func init() {
	// TODO: setup flags here
	flag.Parse()
}

func main() {
	switch flag.NArg() {
	// Given a connection URL
	case 1:
		url := flag.Arg(0)

		if err := inspectSchema(url); err != nil {
			os.Exit(1)
		}

	// (presumably) given a subcommand ("serve") and a file
	case 2:
		panic("Unsupported command mode")

	// Unknown
	default:
		fmt.Println(USAGE)
		os.Exit(1)
	}
}

// There are a bunch, and new ones get added sometimes. Only grabbing
// the possibly useful ones
var InformationSchemaTables = []string{
	"attributes",
	"check_constraints",
	"column_options",
	"columns",
	"domains",
	"element_types",
	"enabled_roles",
	"parameters",
	"routines",
	"sequences",
	"table_constraints",
	"table_privileges",
	"tables",
	"transforms",
	"triggered_update_columns",
	"triggers",
	"user_defined_types",
	"views",
}

// TODO: Return schema object
func inspectSchema(connUrl string) error {
	log.Printf("connecting to %s", connUrl)

	db, err := sql.Open("postgres", connUrl)
	if err != nil {
		log.Printf("couldn't open db: %+v", err)
		return err
	} else if err := db.Ping(); err != nil {
		log.Printf("couldn't ping db: %+v", err)
		return err
	}

	schema := make(map[string]interface{})
	for _, table := range InformationSchemaTables {
		tableData := make([]interface{}, 32)

		q := fmt.Sprintf(`SELECT * FROM information_schema."%s";`, table)
		rows, err := db.Query(q)
		if err != nil {
			log.Printf("couldn't query '%s': %+v", table, err)
			return err
		}
		cols, err := rows.Columns()
		if err != nil {
			log.Printf("what: %+v", err)
			return err
		}

		for rows.Next() {
			row := make(map[string]interface{})

			colData := make([]interface{}, len(cols))
			colPtr := make([]interface{}, len(cols))
			for i, _ := range colData {
				colPtr[i] = &colData[i]
			}

			if err := rows.Scan(colPtr...); err != nil {
				log.Printf("row scan: %+v", err)
				return err
			}

			for i, name := range cols {
				row[name] = colData[i]
			}

			tableData = append(tableData, row)
		}

		schema[table] = tableData
	}

	log.Printf("generated: %+v", schema)

	return nil
}
